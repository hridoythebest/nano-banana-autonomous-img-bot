from dotenv import load_dotenv
load_dotenv()

import os
import json
from google import genai
from PIL import Image
from io import BytesIO
from pathlib import Path
from datetime import datetime
import argparse

# Load API key from environment variable
API_KEY = os.environ.get("GEMINI_API_KEY")
if not API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable is not set. Please set it in your .env file.")

# Configure the client with your API key
client = genai.Client(api_key=API_KEY)


def is_image_file(path: Path) -> bool:
    return path.suffix.lower() in {".jpg", ".jpeg", ".png", ".webp", ".bmp"}


def discover_images(directory: Path) -> list[Path]:
    if not directory.exists() or not directory.is_dir():
        return []
    return [p for p in sorted(directory.iterdir()) if p.is_file() and is_image_file(p)]


def safe_stem(name: str) -> str:
    return "".join(c if c.isalnum() or c in ("-", "_") else "_" for c in name)


def load_prompts(prompt_file: Path) -> list[dict]:
    if not prompt_file.exists():
        raise FileNotFoundError(f"Prompt file not found: {prompt_file}")
    with prompt_file.open("r", encoding="utf-8") as f:
        data = json.load(f)
    prompts = data.get("prompts", [])
    # Each prompt entry expected to have keys: name, text
    cleaned = []
    for i, entry in enumerate(prompts):
        name = entry.get("name") or f"prompt_{i+1:02d}"
        text = entry.get("text")
        if not text:
            continue
        cleaned.append({"name": name, "text": text})
    if not cleaned:
        raise ValueError("No valid prompts found in prompt file.")
    return cleaned


def generate_from_prompt(prompt_name: str, prompt_text: str, product_img: Path, outdir: Path, model_name: str) -> Path | None:
    print(f"\n[Start] Prompt='{prompt_name}' with product='{product_img.name}'")
    try:
        product = Image.open(product_img)
    except Exception as e:
        print(f"[Skip] Failed to open product image: {e}")
        return None

    try:
        response = client.models.generate_content(
            model=model_name,
            contents=[
                prompt_text,
                product,
            ],
        )
    except Exception as e:
        print(f"[Error] API call failed: {e}")
        return None

    try:
        image_parts = [
            part.inline_data.data
            for part in response.candidates[0].content.parts
            if getattr(part, "inline_data", None)
        ]
    except Exception as e:
        print(f"[Error] Unexpected response structure: {e}")
        return None

    if not image_parts:
        print("[Info] No image generated by the model.")
        return None

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    outname = f"bulk_{safe_stem(prompt_name)}__{safe_stem(product_img.stem)}__{timestamp}.jpg"
    outpath = outdir / outname
    try:
        edited_image = Image.open(BytesIO(image_parts[0]))
        edited_image.save(outpath)
        print(f"[Done] Saved: {outpath}")
        return outpath
    except Exception as e:
        print(f"[Error] Failed to save output: {e}")
        return None


def main():
    parser = argparse.ArgumentParser(description="Bulk generate professional ad images from prompts and product images using Gemini.")
    parser.add_argument("--prompt_file", type=str, default=str(Path(__file__).resolve().parents[1] / "prompt.json"), help="Path to prompt JSON file.")
    parser.add_argument("--product_dir", type=str, default=str(Path(__file__).resolve().parents[1] / "product_images"), help="Directory containing product images.")
    parser.add_argument("--outdir", type=str, default=str(Path(__file__).resolve().parents[1] / "bulk_outputs"), help="Directory to save generated images.")
    parser.add_argument("--model", type=str, default="gemini-2.5-flash-image-preview", help="Model name to use.")
    parser.add_argument("--prompt_names", type=str, nargs="*", help="Optional list of prompt names to run (defaults to all).")

    args = parser.parse_args()

    outdir = Path(args.outdir)
    outdir.mkdir(parents=True, exist_ok=True)

    prompts = load_prompts(Path(args.prompt_file))
    if args.prompt_names:
        name_set = set(args.prompt_names)
        prompts = [p for p in prompts if p["name"] in name_set]
        if not prompts:
            raise ValueError("No matching prompts found for the provided --prompt_names.")

    product_dir = Path(args.product_dir)
    product_images = discover_images(product_dir)
    if not product_images:
        raise FileNotFoundError(f"No product images found in {product_dir}")

    print(f"Total generations to run: {len(prompts) * len(product_images)}")
    success = 0
    for p in prompts:
        for q in product_images:
            if generate_from_prompt(p["name"], p["text"], q, outdir, args.model):
                success += 1

    print(f"\nCompleted. Successful generations: {success}/{len(prompts) * len(product_images)}")


if __name__ == "__main__":
    main()
